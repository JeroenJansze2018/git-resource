#!/bin/bash
# vim: set ft=sh

#This script checks if there are newer changes on specific directories, in pullrequests that have state open.
#It returns the current version and all other newer commits in a list, with the current version on top.
#Concourse will skip the first element in that list.

set -e

exec 3>&1 # make stdout available as fd 3 for the result
exec 1>&2 # redirect all output to stderr for logging
exec &>> /tmp/check-logfile #Logging for the check script can only be seen by sending it to a file,
                            #login to the concourse container and checking the file

source $(dirname $0)/common.sh

# for jq
PATH=/usr/local/bin:$PATH

#Gets all input information for the check script
payload=$TMPDIR/git-resource-request

cat > $payload <&0

load_pubkey $payload
configure_https_tunnel $payload
configure_git_ssl_verification $payload
configure_credentials $payload

bitbucket_key=$(jq -r '.source.bitbucket_key // ""' < $payload)
bitbucket_secret=$(jq -r '.source.bitbucket_secret // ""' < $payload)
bitbucket_host=$(jq -r '.source.bitbucket_host // ""' < $payload)
bitbucket_api_version=$(jq -r '.source.bitbucket_api_version // ""' < $payload)
bitbucket_team_name=$(jq -r '.source.bitbucket_team_name // ""' < $payload)
bitbucket_repo_name=$(jq -r '.source.bitbucket_repo_name // ""' < $payload)
uri=$(jq -r '.source.uri // ""' < $payload)
paths="$(jq -r '(.source.paths // ["."])[]' < $payload)" # those "'s are important
ignore_paths="$(jq -r '":!" + (.source.ignore_paths // [])[]' < $payload)" # these ones too
git_config_payload=$(jq -r '.source.git_config // []' < $payload)
ref=$(jq -r '.version.ref // ""' < $payload)
skip_ci_disabled=$(jq -r '.source.disable_ci_skip // false' < $payload)
configure_git_global "${git_config_payload}"

#Temporary destination to clone repo's and check if there are newer versions
destination=$TMPDIR/git-resource-repo-cache

#Check PR's on Bitbucket
#Get access token
ACCESS_TOKEN=$(curl -X POST -u "${bitbucket_key}:${bitbucket_secret}" https://bitbucket.org/site/oauth2/access_token \
-d grant_type=client_credentials -k | jq '.access_token')

echo "Access token retrieved" >> /tmp/check-logfile

#Get all pullrequest from bitbucket
BITBUCKET_PRS_URL="${bitbucket_host}/${bitbucket_api_version}/repositories/${bitbucket_team_name}/${bitbucket_repo_name}/pullrequests"

echo "URL for retrieving prs: "$BITBUCKET_PRS_URL >> /tmp/check-logfile

bitbucket_prs=$(curl -X GET ${BITBUCKET_PRS_URL} \
--header "Content-Type: application/json" \
--header "Authorization: Bearer ${ACCESS_TOKEN}" \
-k)

echo "current prs: $bitbucket_prs" >> /tmp/check-logfile

#references is used to save all references that need to be in the output of the check script.
references=""

#branch is a variable that keeps track of which branch to clone and check for updates
branch=""

#As git checkout changes the work directory we need to be able to find the original work directory for the next branch
original_workdir="$(pwd)"

#Checking all the prs to see if there are any updates on them compared to either the last master commit or the last version
for row in $(echo "${bitbucket_prs}" | jq '.values' | jq -r '.[] | @base64'); do

    _jq() {
        echo ${row} | base64 -d | jq -r ${1}
    }

    echo "Currently checking pr: $(_jq '.')"

    #Only prs with state open are checked (other states are merged, declined or superseded)
    if [ "$(_jq '.state')" = "OPEN" ]; then

        #Get the branch name to be used to clone it
        branch="$(_jq '.source.branch.name')"
        branchflag="--branch $branch"

        cd $original_workdir

        echo "branch: "$branch  >> /tmp/check-logfile

        #Clone the branch and cd into it
        git clone --single-branch $uri $branchflag $destination
        cd $destination

        #Important block
        #This decides whether or not a certain update commit should be in the output based on if there are changes in a certain directory
        if [ "$paths" = "." ] && [ -z "$ignore_paths" ]; then
            paths_search=""
        else
            paths_search="-- $paths $ignore_paths"
        fi

        echo "paths set: "$paths_search  >> /tmp/check-logfile

        potential_updates=$(git diff master...$branch $paths_search)

        update=""
        if [ -n "$potential_updates" ]; then
            update="$(_jq '.source.commit.hash')"

            #If references is currently empty do not put an new line first else do
            if [ -n "$references" ]; then
                set -f
                references=$references$'\n'
                references=$references$update
                set +f
            else
                set -f
                references=$update
                set +f
            fi

            echo "refs updated: $references" >> /tmp/check-logfile
        fi
        
        #Remove current branch to make sure there is room for the next
        rm -rf $destination
    fi
done

#Send output to stdout
echo "$references" | jq -R '.' | jq -s "map({ref: .})" >&3